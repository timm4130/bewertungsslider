<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bewertungsslider</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Alpine.js (CDN) -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>

  <!-- jsPDF (CDN) -->
  <script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg1: #f6fbff;
      --bg2: #f4fff9;
      --card: rgba(255,255,255,.75);
      --stroke: rgba(15, 23, 42, .08);
      --ios-blue: #007AFF;
      --ios-blue-hover: #0066D6;
    }

    .range-wrap{ position: relative; }
    .thumb-tooltip{
      position:absolute;
      top:-0.75rem;
      transform: translate(-50%, -100%);
      left: var(--pos, 50%);
      pointer-events:none;
      max-width: 22rem;
    }

    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      height: 12px;
      border-radius: 999px;
      background: linear-gradient(90deg,
        rgba(244,63,94,.75),
        rgba(251,191,36,.75),
        rgba(34,197,94,.75)
      );
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      background: white;
      border: 2px solid rgba(16,185,129,.65);
      box-shadow: 0 10px 24px rgba(15,23,42,.18);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb{
      width: 24px;
      height: 24px;
      border-radius: 999px;
      background: white;
      border: 2px solid rgba(16,185,129,.65);
      box-shadow: 0 10px 24px rgba(15,23,42,.18);
      cursor: pointer;
    }
  </style>
</head>

<body class="relative min-h-screen bg-gradient-to-br from-[var(--bg1)] to-[var(--bg2)] text-slate-900"
      x-data="bewertungApp()"
      x-init="init()">

  <!-- OBEN -->
  <div class="max-w-6xl mx-auto px-5 py-10">
    <header class="text-center space-y-4">
      <div class="flex justify-center">
        <div class="w-[18rem] max-w-[75vw] text-left">
          <div class="text-xs uppercase tracking-wide text-slate-500 font-semibold mb-1">Name</div>
          <input
            x-model="studentName"
            class="w-full bg-white/80 border border-slate-200 rounded-xl px-3 py-2 text-base font-semibold text-slate-800 shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-200"
            placeholder="NAME EINGEBEN"
            aria-label="Name"
          />
        </div>
      </div>

      <div class="inline-flex flex-col items-center gap-2">
        <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
          Bewertungsslider
          <span class="text-slate-600 font-medium">–</span>
          <span class="inline-flex items-center gap-2 align-middle">
            <input
              x-model="topic"
              class="w-[18rem] max-w-[75vw] bg-white/80 border border-slate-200 rounded-xl px-3 py-2 text-base font-semibold text-slate-800 shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-200"
              placeholder="THEMA DER PRÜFUNG EINFÜGEN"
              aria-label="Thema der Prüfung"
            />
          </span>
        </h1>
      </div>
    </header>

    <section class="mt-8">
      <div class="flex items-center justify-center md:justify-end gap-2">
        <button
          class="px-3 py-2 rounded-xl bg-emerald-600 text-white shadow-sm hover:bg-emerald-700 transition text-sm"
          @click="generatePdf()">
          Bewertungsbogen erstellen
        </button>
      </div>
    </section>

    <main class="mt-6">
      <div class="rounded-3xl border border-[var(--stroke)] bg-[var(--card)] shadow-sm backdrop-blur-md overflow-hidden">
        <div class="hidden md:grid grid-cols-12 gap-4 px-6 py-4 border-b border-slate-200/70 text-xs font-semibold text-slate-600 uppercase tracking-wide">
          <div class="col-span-2">Gewichtung (%)</div>
          <div class="col-span-4">Bewertungskriterium</div>
          <div class="col-span-6">Bewertung</div>
        </div>

        <template x-for="(c, idx) in criteria" :key="c.id">
          <div class="grid grid-cols-1 md:grid-cols-12 gap-4 px-6 py-6 border-b border-slate-200/60 last:border-b-0">
            <div class="md:col-span-2">
              <label class="md:hidden text-xs font-semibold text-slate-600 uppercase tracking-wide">Gewichtung (%)</label>
              <div class="mt-2 md:mt-0 flex items-center gap-2">
                <input
                  type="number"
                  min="0"
                  max="100"
                  step="1"
                  x-model.number="c.weight"
                  class="w-24 bg-white/90 border border-slate-200 rounded-xl px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-200"
                  :aria-label="'Gewichtung für Kriterium ' + (idx + 1)"
                />
                <span class="text-sm text-slate-500">%</span>
              </div>
            </div>

            <div class="md:col-span-4">
              <label class="md:hidden text-xs font-semibold text-slate-600 uppercase tracking-wide">Bewertungskriterium</label>
              <div class="mt-2 md:mt-0">
                <div x-show="!((c.title||'').trim() || (c.short||'').trim())"
                     class="text-sm text-slate-500 font-normal">
                  Hier wird das Bewertungskriterium und eine knappe Beschreibung angezeigt
                </div>

                <div x-show="((c.title||'').trim() || (c.short||'').trim())">
                  <div class="text-base font-semibold text-slate-900" x-text="c.title"></div>
                  <div class="text-sm text-slate-600 mt-1" x-text="c.short"></div>
                </div>
              </div>
            </div>

            <div class="md:col-span-6">
              <label class="md:hidden text-xs font-semibold text-slate-600 uppercase tracking-wide">Bewertung</label>

              <div class="mt-2 md:mt-0 range-wrap" x-effect="updateTooltipPos(idx)">
                <div class="thumb-tooltip" :style="`--pos: ${criteria[idx].tooltipPos}%`">
                  <div class="rounded-2xl border border-slate-200 bg-white/95 shadow-md px-3 py-2">
                    <div class="leading-tight">
                      <span class="text-sm font-semibold text-slate-900" x-text="qualityLabel(c.value)"></span>
                    </div>
                  </div>
                </div>

                <div class="relative mt-6">
                  <div class="pointer-events-none absolute inset-x-0 top-1/2 -translate-y-1/2 h-4">
                    <div class="absolute left-1/4 top-0 bottom-0 border-l border-slate-400/40"></div>
                    <div class="absolute left-1/2 top-0 bottom-0 border-l border-slate-400/40"></div>
                    <div class="absolute left-3/4 top-0 bottom-0 border-l border-slate-400/40"></div>
                  </div>

                  <input
                    type="range"
                    min="0"
                    max="100"
                    step="0.1"
                    x-model.number="c.value"
                    class="w-full"
                    :aria-label="'Slider für Kriterium ' + (idx + 1)"
                  />
                </div>
              </div>

              <div class="mt-3">
                <div class="space-y-2">
                  <template x-for="(t, tIdx) in c.texts" :key="tIdx">
                    <div class="rounded-2xl border border-slate-200/70 px-3 py-2"
                         :class="tIdx === qualityIndex(c.value) ? 'bg-white/90' : 'bg-white/40'">
                      <div class="leading-tight">
                        <span
                          :class="tIdx === qualityIndex(c.value) ? 'text-xs text-slate-900 font-semibold' : 'text-[11px] text-slate-400 font-medium'"
                          x-text="qualityLabels[tIdx]"></span>
                      </div>

                      <div class="mt-1 leading-snug"
                           :class="tIdx === qualityIndex(c.value) ? 'text-sm text-slate-800 font-normal' : 'text-xs text-slate-400'"
                           x-text="t"></div>
                    </div>
                  </template>
                </div>
              </div>

            </div>
          </div>
        </template>
      </div>
    </main>

    <footer class="mt-8 text-center text-xs text-slate-500">
      <span>Summe Gewichtung: </span>
      <span class="font-medium"
            :class="weightSum === 100 ? 'text-emerald-700' : 'text-rose-700'"
            x-text="weightSum + ' %'"></span>
      <span class="text-slate-400" x-show="weightSum !== 100">(Ziel: 100 %)</span>
    </footer>

    <div class="mt-5 flex justify-center">
      <div x-ref="stopMarker" class="rounded-2xl border border-[var(--stroke)] bg-white/80 shadow-md backdrop-blur-md px-4 py-2 text-sm md:text-base font-semibold text-slate-900">
        ⬇️ Bewertungskriterien und Qualitätsstufen ⬇️
      </div>
    </div>
  </div>

  <!-- UNTEN: Editor (zentriert, gleiche Breite wie oben) -->
  <section class="w-full mt-6">
    <div class="max-w-6xl mx-auto px-5">
      <div class="rounded-3xl border border-[var(--stroke)] bg-white/80 shadow-lg backdrop-blur-md p-5">

        <div class="text-sm text-slate-700 leading-snug">
          Erstelle mit Hilfe eines Sprachmodells wie ChatGPT (idealerweise auf Grundlage eines möglichst differenzierten Erwartungshorizontes) vier „Qualitätsstufen“ der Lösung der Bewertungskriteriums. Prompt etwa:
        </div>

        <div class="mt-3 rounded-2xl border border-slate-200 bg-white/90 shadow-sm p-4">
          <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-3">
            <pre class="whitespace-pre-wrap text-[10px] text-slate-700 leading-snug flex-1" x-text="examplePrompt"></pre>

            <button
              class="shrink-0 px-3 py-2 rounded-xl bg-slate-900 text-white shadow-sm hover:bg-slate-800 transition text-sm"
              @click="copyPrompt()">
              copy prompt
            </button>
          </div>
        </div>

        <div class="mt-5 space-y-4">
          <template x-for="(row, rIdx) in editorRows" :key="rIdx">
            <div class="grid grid-cols-1 md:grid-cols-12 gap-4">

              <div class="md:col-span-5">
                <div class="text-xs uppercase tracking-wide text-slate-500 font-semibold mb-1 whitespace-nowrap">
                  BEWERTUNGSKRITERIUM UND KNAPPE BESCHREIBUNG
                </div>
                <textarea
                  class="w-full min-h-[7rem] bg-white/90 border border-slate-200 rounded-2xl px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-200"
                  placeholder="1. Zeile: Bewertungskriterium&#10;ab 2. Zeile: Kurzbeschreibung"
                  x-model="row.left"
                  @input="syncCriteriaFromEditor()"
                ></textarea>
              </div>

              <div class="md:col-span-7">
                <div class="text-xs uppercase tracking-wide text-slate-500 font-semibold mb-1">
                  LÖSUNGSQUALITÄT
                </div>

                <div class="flex items-stretch gap-2">
                  <textarea
                    class="flex-1 w-full min-h-[7rem] bg-white/90 border border-slate-200 rounded-2xl px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-200"
                    placeholder="Wichtig: bitte Stufen exakt als 1. / 2. / 3. / 4. (jeweils neue Zeile).&#10;&#10;1. ...&#10;&#10;2. ...&#10;&#10;3. ...&#10;&#10;4. ..."
                    x-model="row.right"
                    @input="syncCriteriaFromEditor()"
                  ></textarea>

                  <!-- Apple-style X -->
                  <button
                    type="button"
                    class="shrink-0 self-center w-6 h-6 rounded-full bg-white/90 border border-slate-200 text-slate-700
                           shadow-sm hover:bg-slate-50 transition flex items-center justify-center text-sm font-semibold"
                    aria-label="Diese Zeile löschen"
                    title="Diese Zeile löschen"
                    @click="removeEditorRow(rIdx)"
                  >×</button>
                </div>
              </div>

            </div>
          </template>

          <!-- Apple-style Plus -->
          <div class="flex justify-center pt-2">
            <button
              class="w-12 h-12 rounded-full text-white shadow-md transition flex items-center justify-center text-2xl leading-none
                     bg-[var(--ios-blue)] hover:bg-[var(--ios-blue-hover)]"
              aria-label="Neue Zeile hinzufügen"
              @click="addEditorRow()">
              +
            </button>
          </div>

          <!-- Optional: LLM Output (outer box = Hintergrundfarbe / transparent) -->
          <div class="mt-4 bg-transparent p-0">
            <div class="text-xs uppercase tracking-wide text-slate-500 font-semibold">
              OPTIONAL: OUTPUT DES SPRACHMODELL EINFÜGEN.
            </div>

            <textarea
              class="mt-2 w-full min-h-[10rem] bg-white/90 border border-slate-200 rounded-2xl px-3 py-2 text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-emerald-200"
              placeholder="Hier den kompletten Output einfügen (Markdown ist ok)."
              x-model="llmOutputRaw"
            ></textarea>

            <div class="mt-3 flex items-center justify-end gap-2">
              <button
                type="button"
                class="px-3 py-2 rounded-xl bg-slate-900 text-white shadow-sm hover:bg-slate-800 transition text-sm"
                @click="assignFromLLMOutput()"
              >
                zuweisen
              </button>
            </div>

            <div class="mt-2 text-xs text-slate-500" x-show="llmAssignInfo">
              <span x-text="llmAssignInfo"></span>
            </div>
          </div>

        </div>
      </div>

      <!-- VORLAGEN/LETZTE PROJEKTE: ganz unten, schmal, bündig links am unteren Kasten -->
      <div class="mt-6 flex justify-start pb-10">
        <div class="w-[20rem] max-w-full rounded-3xl border border-[var(--stroke)] bg-white/80 shadow-lg backdrop-blur-md p-5">
          <div class="text-xs uppercase tracking-wide text-slate-500 font-semibold">Vorlagen/letzte Projekte</div>
          <div class="text-[11px] text-slate-500 mt-1">Letzte 5 (lokal im Browser gespeichert)</div>

          <div class="mt-4 space-y-2">
            <template x-if="projectLibrary.length === 0">
              <div class="rounded-2xl border border-slate-200 bg-white/70 px-3 py-3 text-sm text-slate-500">
                Noch keine Projekte gespeichert.
              </div>
            </template>

            <template x-for="p in projectLibrary" :key="p.id">
              <button
                type="button"
                class="w-full text-left rounded-2xl border border-slate-200 bg-white/70 hover:bg-white transition px-3 py-2"
                @click="loadLibraryProject(p.id)"
              >
                <div class="text-sm font-semibold text-slate-900 truncate" x-text="p.topic || p.title || 'Projekt'"></div>
                <div class="text-[11px] text-slate-400 mt-0.5" x-text="p.timestamp ? '(' + formatDate(p.timestamp) + ')' : ''"></div>
              </button>
            </template>
          </div>

          <div class="mt-5 pt-4 border-t border-slate-200/70 space-y-2">
            <button
              type="button"
              class="w-full px-3 py-2 rounded-xl bg-slate-900 text-white shadow-sm hover:bg-slate-800 transition text-sm"
              @click="exportProject()"
            >
              Projekt speichern/exportieren
            </button>

            <button
              type="button"
              class="w-full px-3 py-2 rounded-xl bg-white/90 border border-slate-200 text-slate-900 shadow-sm hover:bg-white transition text-sm"
              @click="triggerImport()"
            >
              Projekt laden
            </button>
          </div>
        </div>
      </div>

    </div>
  </section>

  <!-- Versteckter Import-Input -->
  <input
    x-ref="importInput"
    type="file"
    accept="application/json,.json"
    class="hidden"
    @change="handleImportFile($event)"
  />

  <!-- Ergebnis-Box -->
  <div
    x-ref="resultBox"
    class="z-50 w-[22rem] max-w-[92vw]"
    :class="resultMode === 'fixed' ? 'fixed' : 'absolute'"
    :style="resultMode === 'fixed'
      ? `right:${resultRight}px; bottom:${resultBottom}px;`
      : `right:${resultRight}px; top:${resultTop}px;`"
  >
    <div class="rounded-3xl border border-[var(--stroke)] bg-white/80 shadow-lg backdrop-blur-md p-4">
      <div class="flex items-start justify-between gap-3">
        <div>
          <div class="text-xs uppercase tracking-wide text-slate-500 font-semibold">Ergebnis</div>
          <div class="text-xl font-semibold mt-1" x-text="'Gesamtnote: ' + (overallGrade.symbol || '')"></div>
          <div class="text-sm text-slate-600 mt-1" x-text="overallGrade.label"></div>
        </div>
      </div>

      <div class="mt-3 text-xs text-slate-600 leading-snug" x-show="weightSum !== 100">
        Hinweis: Summe ist nicht 100%. Die Gesamtnote basiert trotzdem auf den eingegebenen Prozentwerten.
      </div>
    </div>
  </div>

  <script>
    function bewertungApp() {
      return {
        topic: '',
        studentName: '',

        qualityLabels: [
          'Hervorragend erreicht',
          '(voll) erreicht',
          'Mit Abzügen erreicht',
          'Mit deutlichen Abzügen / Kaum erreicht'
        ],

        examplePrompt:
`Du erhältst einen Erwartungshorizont (entspricht der bestmöglichen Leistung). Wandle ihn in ein kompaktes Bewertungsraster mit 4 Qualitätsstufen um.

Regeln:

-Extrahiere aus dem Erwartungshorizont alle relevanten Bewertungskriterien
-Formuliere die Kriterien abstrakt/übergeordnet (paraphrasierend), ohne Textteile aus dem Erwartungshorizont wörtlich zu übernehmen.
-Keine Detail-Aufzählungen aus dem Erwartungshorizont; stattdessen kurze Zusammenfassungen, was übergeordnet erreicht werden soll.
-Jedes Bewertungskriterium muss in 4 unterschiedlichen Qualitätsstufen beschrieben werden.
-Pro Qualitätsstufe maximal 1–2 Sätze; klare, prüfbare Formulierungen.
-Differenziere die Stufen über: Umfang/Vollständigkeit, Differenziertheit, Begründung/Belegführung, Präzision der Fachbegriffe, Stringenz, Fehlerdichte (je nach Kriterium passend).
-Nutze ggf. Klammern für typische Beispiele als Orientierung, aber nur sehr knapp (z. B. „Wortwahl/Syntax/Bildsprache“), ohne den Erwartungshorizont auszubreiten.

Ausgabeformat (zwingend, copy-paste-fertig):

BEWERTUNGSKRITERIUM UND KNAPPE BESCHREIBUNG
[Bewertungskriterium in 1 Zeile]
[Kurzbeschreibung 1–2 Sätze]

LÖSUNGSQUALITÄT
Wichtig: Die vier Stufen müssen exakt in dieser Reihenfolge ausgegeben werden:
1 = beste Qualität, 2 = gute/solide Qualität, 3 = erkennbar aber lückenhaft/fehlerhaft, 4 = schwach/kaum erreicht.

Formatregeln (streng einhalten):
- Jede Stufe beginnt in einer neuen Zeile exakt mit "1. " / "2. " / "3. " / "4. " (Ziffer + Punkt + Leerzeichen).
- Danach folgt nur der Feedback-Text (1–2 Sätze). Keine Überschriften, keine Labels, keine Klammern mit Noten, keine Fettschrift, keine Bulletpoints.
- Zwischen den Stufen jeweils eine Leerzeile.

Ausgabe (exakt so):
1. [Text]

2. [Text]

3. [Text]

4. [Text]`,

        editorRows: [
          { left: '', right: '' },
          { left: '', right: '' },
          { left: '', right: '' }
        ],

        criteria: [],

        // Bibliothek (letzte 5)
        storageKey: 'bewertung_last_projects_v1',
        projectLibrary: [],

        // LLM-Output-Zuweisung
        llmOutputRaw: '',
        llmAssignInfo: '',

        // Ergebnis-Box
        resultMode: 'fixed',
        resultTop: 0,
        resultRight: 20,
        resultBottom: 20,
        _raf: false,
        _onScroll: null,
        _onResize: null,

        init() {
          this.resetDefaults();
          this.loadLibrary();
          this.syncCriteriaFromEditor();

          this.$nextTick(() => {
            this.updateResultStop();

            this._onScroll = () => {
              if (this._raf) return;
              this._raf = true;
              requestAnimationFrame(() => {
                this._raf = false;
                this.updateResultStop();
              });
            };

            this._onResize = () => {
              if (this._raf) return;
              this._raf = true;
              requestAnimationFrame(() => {
                this._raf = false;
                this.updateResultStop();
              });
            };

            window.addEventListener('scroll', this._onScroll, { passive: true });
            window.addEventListener('resize', this._onResize, { passive: true });
          });
        },

        updateResultStop() {
          if (!this.$refs || !this.$refs.resultBox || !this.$refs.stopMarker) return;

          const boxH = this.$refs.resultBox.offsetHeight || 0;
          const markerBottom = this.$refs.stopMarker.getBoundingClientRect().bottom + window.scrollY;
          const docBottomFixed = window.scrollY + window.innerHeight - this.resultBottom;

          if (docBottomFixed >= markerBottom) {
            this.resultMode = 'absolute';
            this.resultTop = Math.max(8, markerBottom - boxH);
          } else {
            this.resultMode = 'fixed';
          }
        },

        makeId() {
          try { return crypto.randomUUID(); } catch (_) {}
          return 'k_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2);
        },

        deepClone(x) {
          try { return JSON.parse(JSON.stringify(x)); } catch (_) { return null; }
        },

        formatDate(ts) {
          try { return new Date(Number(ts) || Date.now()).toLocaleDateString('de-DE'); }
          catch (_) { return ''; }
        },

        // Bibliothek
        loadLibrary() {
          try {
            const raw = localStorage.getItem(this.storageKey);
            const arr = raw ? JSON.parse(raw) : [];
            this.projectLibrary = Array.isArray(arr) ? arr.slice(0, 5) : [];
          } catch (_) {
            this.projectLibrary = [];
          }
        },

        saveLibrary() {
          try { localStorage.setItem(this.storageKey, JSON.stringify((this.projectLibrary || []).slice(0, 5))); }
          catch (_) {}
        },

        buildProjectPayload() {
          const now = Date.now();
          const topic = String(this.topic || '').trim();

          const payload = {
            id: this.makeId(),
            title: topic || 'Projekt',
            topic,
            timestamp: now,
            editorRows: this.deepClone(this.editorRows) || [{ left: '', right: '' }],
            criteria: this.deepClone(this.criteria) || []
          };

          payload.criteria = Array.isArray(payload.criteria)
            ? payload.criteria.slice(0, payload.editorRows.length)
            : [];

          return payload;
        },

        pushToLibrary(payload) {
          if (!payload || !payload.id) return;
          this.projectLibrary = [payload, ...(this.projectLibrary || [])].slice(0, 5);
          this.saveLibrary();
        },

        loadProjectPayload(payload) {
          if (!payload) return;

          const editorRows = Array.isArray(payload.editorRows) ? this.deepClone(payload.editorRows) : null;
          const criteria = Array.isArray(payload.criteria) ? this.deepClone(payload.criteria) : null;

          if (!editorRows || editorRows.length === 0) return;

          this.topic = String(payload.topic || '').trim();
          this.editorRows = editorRows;

          if (criteria && criteria.length) {
            this.criteria = criteria.slice(0, this.editorRows.length);
            for (let i = 0; i < this.editorRows.length; i++) this.ensureCriterion(i);
          } else {
            this.criteria = [];
          }

          this.$nextTick(() => {
            this.syncCriteriaFromEditor();
            this.updateResultStop();
          });
        },

        loadLibraryProject(projectId) {
          const p = (this.projectLibrary || []).find(x => x && x.id === projectId);
          if (!p) return;
          this.loadProjectPayload(p);
        },

        exportProject() {
          const payload = this.buildProjectPayload();
          this.pushToLibrary(payload);

          const safe = (s) => (String(s || '')
            .split('')
            .filter(ch => /[a-z0-9äöüß _-]/i.test(ch))
            .join('')
            .trim()
            .replaceAll(' ', '_')) || 'Projekt';

          const fileName = `Bewertungsslider_${safe(payload.title)}_${this.formatDate(payload.timestamp).replaceAll('.', '-')}.json`;
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          URL.revokeObjectURL(url);
        },

        triggerImport() {
          if (this.$refs && this.$refs.importInput) {
            this.$refs.importInput.value = '';
            this.$refs.importInput.click();
          }
        },

        handleImportFile(evt) {
          const file = evt && evt.target && evt.target.files ? evt.target.files[0] : null;
          if (!file) return;

          const reader = new FileReader();
          reader.onload = () => {
            try {
              const data = JSON.parse(String(reader.result || ''));
              const ok = data && typeof data === 'object'
                && Array.isArray(data.editorRows)
                && data.editorRows.length > 0;

              if (!ok) return;

              if (!data.id) data.id = this.makeId();
              if (!data.timestamp) data.timestamp = Date.now();
              if (!data.topic) data.topic = '';
              if (!data.title) data.title = String(data.topic || '').trim() || 'Import';

              const payload = {
                id: data.id,
                title: data.title,
                topic: String(data.topic || '').trim(),
                timestamp: Number(data.timestamp) || Date.now(),
                editorRows: this.deepClone(data.editorRows) || [{ left: '', right: '' }],
                criteria: Array.isArray(data.criteria) ? this.deepClone(data.criteria) : []
              };
              payload.criteria = payload.criteria.slice(0, payload.editorRows.length);

              this.loadProjectPayload(payload);
              this.pushToLibrary(payload);
            } catch (_) {}
          };
          reader.readAsText(file);
        },

        resetDefaults() {
          const placeholderText = 'Hier erscheint eine konkrete Beschreibung dieser Lösungsqualität.';
          this.criteria = [
            { id: this.makeId(), title: '', short: '', weight: 50, value: 70, tooltipPos: 70, texts: [placeholderText, placeholderText, placeholderText, placeholderText] },
            { id: this.makeId(), title: '', short: '', weight: 50, value: 70, tooltipPos: 70, texts: [placeholderText, placeholderText, placeholderText, placeholderText] }
          ];
        },

        addEditorRow() {
          this.editorRows.push({ left: '', right: '' });
          this.syncCriteriaFromEditor();
          this.$nextTick(() => this.updateResultStop());
        },

        removeEditorRow(i) {
          const idx = Number(i);
          if (!Number.isFinite(idx)) return;

          const placeholderText = 'Hier erscheint eine konkrete Beschreibung dieser Lösungsqualität.';

          if (this.editorRows.length <= 1) {
            this.editorRows[0] = { left: '', right: '' };

            if (!this.criteria.length) {
              this.criteria = [{
                id: this.makeId(),
                title: '',
                short: '',
                weight: 0,
                value: 70,
                tooltipPos: 70,
                texts: [placeholderText, placeholderText, placeholderText, placeholderText]
              }];
            } else {
              this.criteria[0].title = '';
              this.criteria[0].short = '';
              this.criteria[0].texts = [placeholderText, placeholderText, placeholderText, placeholderText];
            }

            this.$nextTick(() => this.updateResultStop());
            return;
          }

          if (idx < 0 || idx >= this.editorRows.length) return;

          this.editorRows.splice(idx, 1);
          if (idx < this.criteria.length) this.criteria.splice(idx, 1);

          this.$nextTick(() => {
            this.syncCriteriaFromEditor();
            this.updateResultStop();
          });
        },

        async copyPrompt() {
          const txt = String(this.examplePrompt || '');
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(txt);
              return;
            }
          } catch (_) {}

          const ta = document.createElement('textarea');
          ta.value = txt;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        },

        ensureCriterion(i) {
          const placeholderText = 'Hier erscheint eine konkrete Beschreibung dieser Lösungsqualität.';
          while (this.criteria.length <= i) {
            this.criteria.push({
              id: this.makeId(),
              title: '',
              short: '',
              weight: 0,
              value: 70,
              tooltipPos: 70,
              texts: [placeholderText, placeholderText, placeholderText, placeholderText]
            });
          }
        },

        // Markdown-robust
        stripMarkdownInline(s) {
          return String(s || '')
            .replace(/\*\*(.+?)\*\*/g, '$1')
            .replace(/__(.+?)__/g, '$1')
            .replace(/\*(.+?)\*/g, '$1')
            .replace(/_(.+?)_/g, '$1')
            .replace(/`(.+?)`/g, '$1');
        },

        normalizeLLMText(raw) {
          let t = String(raw || '').replace(/\r\n/g, '\n');
          t = t.replace(/```[\s\S]*?```/g, (m) => m.replace(/```/g, ''));
          t = t.replace(/^\s*(#{1,6}\s+|>\s+|[-*+]\s+)\s*/gm, '');
          t = this.stripMarkdownInline(t);
          t = t.replace(/[ \t]+/g, ' ');
          return t.trim();
        },

        parseLeft(left) {
          const raw = this.stripMarkdownInline(String(left || '').replace(/\r\n/g, '\n'));
          const lines = raw.split('\n');
          const first = lines.findIndex(l => l.trim().length > 0);
          if (first === -1) return { title: '', short: '' };
          const title = (lines[first] || '').trim();
          const short = lines.slice(first + 1).join('\n').trim();
          return { title, short };
        },

        parseRight(right) {
          const raw = this.stripMarkdownInline(String(right || '').replace(/\r\n/g, '\n')).trim();
          if (!raw) return ['', '', '', ''];

          const re = /(?:^|\n)\s*([1-4])\s*(?:[)\.:－-])\s+/g;
          const matches = [];
          let m;
          while ((m = re.exec(raw)) !== null) {
            matches.push({ n: Number(m[1]), start: m.index + m[0].length, idx: m.index });
          }
          if (matches.length >= 2) {
            matches.sort((a, b) => a.idx - b.idx);
            const out = ['', '', '', ''];
            for (let k = 0; k < matches.length; k++) {
              const cur = matches[k];
              const next = matches[k + 1];
              const end = next ? next.idx : raw.length;
              const block = raw.slice(cur.start, end).trim();
              if (cur.n >= 1 && cur.n <= 4) out[cur.n - 1] = block;
            }
            return out;
          }

          const blocks = raw.split(/\n\s*\n+/).map(s => s.trim()).filter(Boolean);
          return [blocks[0] || '', blocks[1] || '', blocks[2] || '', blocks[3] || ''];
        },

        syncCriteriaFromEditor() {
          const placeholderText = 'Hier erscheint eine konkrete Beschreibung dieser Lösungsqualität.';

          for (let i = 0; i < this.editorRows.length; i++) {
            this.ensureCriterion(i);
            const row = this.editorRows[i] || { left: '', right: '' };

            const { title, short } = this.parseLeft(row.left);
            this.criteria[i].title = title;
            this.criteria[i].short = short;

            const texts = this.parseRight(row.right).map(t => String(t || '').trim());
            const allEmpty = texts.every(t => !t);

            if (!allEmpty) {
              this.criteria[i].texts = [texts[0] || '', texts[1] || '', texts[2] || '', texts[3] || ''];
            } else {
              if (!this.criteria[i].texts || this.criteria[i].texts.length !== 4) {
                this.criteria[i].texts = [placeholderText, placeholderText, placeholderText, placeholderText];
              }
            }
          }

          if (this.criteria.length > this.editorRows.length) {
            this.criteria = this.criteria.slice(0, this.editorRows.length);
          }
        },

        // LLM Output -> EditorRows
        parseLLMOutputToRows(raw) {
          const txt = this.normalizeLLMText(raw);
          if (!txt) return [];

          const reCrit = /(?:^|\n)\s*BEWERTUNGSKRITERIUM UND KNAPPE BESCHREIBUNG\s*\n+/gi;
          const matches = [];
          let m;
          while ((m = reCrit.exec(txt)) !== null) {
            matches.push({ start: m.index, end: m.index + m[0].length });
          }
          if (!matches.length) return [];

          const rows = [];
          for (let i = 0; i < matches.length; i++) {
            const secStart = matches[i].end;
            const secEnd = (i + 1 < matches.length) ? matches[i + 1].start : txt.length;
            const sec = txt.slice(secStart, secEnd).trim();
            if (!sec) continue;

            const reQ = /(?:^|\n)\s*LÖSUNGSQUALITÄT\s*\n+/gi;
            const qm = reQ.exec(sec);
            if (!qm) continue;

            const leftPart = sec.slice(0, qm.index).trim();
            const rightPart = sec.slice(qm.index + qm[0].length).trim();

            const lines = leftPart.split('\n').map(x => x.trim()).filter(Boolean);
            const title = (lines[0] || '').trim();
            const short = lines.slice(1).join('\n').trim();

            rows.push({
              left: (title + (short ? '\n' + short : '')).trim(),
              right: rightPart
            });
          }

          return rows;
        },

        assignFromLLMOutput() {
          const rows = this.parseLLMOutputToRows(this.llmOutputRaw);

          if (!rows.length) {
            this.llmAssignInfo = 'Keine Blöcke gefunden. Erwartet: "BEWERTUNGSKRITERIUM UND KNAPPE BESCHREIBUNG" + "LÖSUNGSQUALITÄT".';
            return;
          }

          this.editorRows = rows;

          for (let i = 0; i < this.editorRows.length; i++) this.ensureCriterion(i);
          if (this.criteria.length > this.editorRows.length) this.criteria = this.criteria.slice(0, this.editorRows.length);

          this.$nextTick(() => {
            this.syncCriteriaFromEditor();
            this.updateResultStop();
          });

          this.llmAssignInfo = `${rows.length} Kriterium/Kriterien zugewiesen.`;
        },

        get weightSum() {
          return this.criteria.reduce((s, c) => s + (Number(c.weight) || 0), 0);
        },

        qualityIndex(v) {
          const x = Number(v) || 0;
          if (x >= 75) return 0;
          if (x >= 50) return 1;
          if (x >= 25) return 2;
          return 3;
        },

        qualityLabel(v) {
          return this.qualityLabels[this.qualityIndex(v)];
        },

        currentFeedback(c) {
          const idx = this.qualityIndex(c.value);
          const t = (c.texts && c.texts[idx]) ? c.texts[idx] : '';
          return t || 'Hier erscheint eine konkrete Beschreibung dieser Lösungsqualität.';
        },

        updateTooltipPos(idx) {
          const c = this.criteria[idx];
          if (!c) return;
          const v = Math.max(0, Math.min(100, Number(c.value) || 0));
          c.tooltipPos = v;
        },

        internalPointsFromValue(v) {
          const x = Math.max(0, Math.min(100, Number(v) || 0));
          return (x / 100) * 15;
        },

        get overallPoints() {
          const sum = this.criteria.reduce((acc, c) => {
            const w = (Number(c.weight) || 0) / 100;
            return acc + this.internalPointsFromValue(c.value) * w;
          }, 0);
          return Math.max(0, Math.min(15, sum));
        },

        gradeFromPoints(p) {
          const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
          const pts = clamp(Number(p) || 0, 0, 15);

          const gradeAt = [6.0, 5.3, 5.0, 4.7, 4.3, 4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7];
          const labelAt = ['ungenügend','mangelhaft (minus)','mangelhaft','mangelhaft (plus)','ausreichend (minus)','ausreichend','ausreichend (plus)','befriedigend (minus)','befriedigend','befriedigend (plus)','gut (minus)','gut','gut (plus)','sehr gut (minus)','sehr gut','sehr gut (plus)'];
          const symbolAt = ['6','5-','5','5+','4-','4','4+','3-','3','3+','2-','2','2+','1-','1','1+'];

          const lo = Math.floor(pts);
          const hi = Math.ceil(pts);
          const t = hi === lo ? 0 : (pts - lo) / (hi - lo);
          const g = gradeAt[lo] + (gradeAt[hi] - gradeAt[lo]) * t;

          const gRounded = Math.round(g * 10) / 10;
          const idxNote = Math.round(pts);

          return {
            note: gRounded.toFixed(1).replace('.', ','),
            label: labelAt[idxNote],
            symbol: symbolAt[idxNote],
            numeric: gRounded,
            points: pts
          };
        },

        get overallGrade() {
          return this.gradeFromPoints(this.overallPoints);
        },

        generatePdf() {
          const jsPDF = window.jspdf && window.jspdf.jsPDF;
          if (!jsPDF) { alert('PDF-Generator (jsPDF) ist nicht geladen.'); return; }

          const doc = new jsPDF({ unit: 'pt', format: 'a4' });
          const pageW = doc.internal.pageSize.getWidth();
          const pageH = doc.internal.pageSize.getHeight();
          const margin = 44;
          const maxTextW = pageW - margin * 2;

          const topic = (this.topic || 'THEMA DER PRÜFUNG').trim();
          const studentName = (this.studentName || 'NAME').trim();
          const dateStr = new Date().toLocaleDateString('de-DE');
          let y = margin;

          doc.setFont('helvetica', 'bold'); doc.setFontSize(16);
          doc.text('Bewertungsbogen', margin, y); y += 20;

          doc.setFont('helvetica', 'normal'); doc.setFontSize(11); doc.setTextColor(60);
          doc.text(`Name: ${studentName}`, margin, y); y += 14;
          doc.text(`Thema: ${topic}`, margin, y); y += 14;
          doc.text(`Datum: ${dateStr}`, margin, y); y += 18;

          doc.setDrawColor(200);
          doc.line(margin, y, pageW - margin, y); y += 18;

          const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
          const lerp = (a, b, t) => a + (b - a) * t;
          const colorForValue = (v) => {
            const x = clamp(Number(v) || 0, 0, 100);
            const r1 = [244, 63, 94], r2 = [251, 191, 36], r3 = [34, 197, 94];
            if (x <= 50) {
              const t = x / 50;
              return [Math.round(lerp(r1[0], r2[0], t)), Math.round(lerp(r1[1], r2[1], t)), Math.round(lerp(r1[2], r2[2], t))];
            }
            const t = (x - 50) / 50;
            return [Math.round(lerp(r2[0], r3[0], t)), Math.round(lerp(r2[1], r3[1], t)), Math.round(lerp(r2[2], r3[2], t))];
          };

          const ensureSpace = (need) => {
            if (y + need > pageH - margin) { doc.addPage(); y = margin; }
          };

          for (let i = 0; i < this.criteria.length; i++) {
            const c = this.criteria[i];
            ensureSpace(170);

            const title = (c.title || '').trim() || `Kriterium ${i + 1}`;
            const w = Number(c.weight) || 0;

            doc.setTextColor(20); doc.setFont('helvetica', 'normal'); doc.setFontSize(11);
            doc.text(`${title} (${w}%)`, margin, y); y += 14;

            doc.setFont('helvetica', 'bold'); doc.setFontSize(11); doc.setTextColor(15);
            doc.text(`Einstufung: ${this.qualityLabel(c.value)}`, margin, y); y += 12;

            doc.setFont('helvetica', 'normal'); doc.setFontSize(10); doc.setTextColor(70);

            const barX = margin, barY = y, barW = Math.min(360, maxTextW - 10), barH = 10;

            doc.setDrawColor(170); doc.rect(barX, barY, barW, barH);

            const v = clamp(Number(c.value) || 0, 0, 100);
            const fillW = (barW * v) / 100;
            const [cr, cg, cb] = colorForValue(v);
            doc.setFillColor(cr, cg, cb);
            doc.rect(barX, barY, fillW, barH, 'F');

            doc.setDrawColor(220);
            doc.line(barX + barW * 0.25, barY - 2, barX + barW * 0.25, barY + barH + 2);
            doc.line(barX + barW * 0.50, barY - 2, barX + barW * 0.50, barY + barH + 2);
            doc.line(barX + barW * 0.75, barY - 2, barX + barW * 0.75, barY + barH + 2);

            y += 22;

            const fb = this.currentFeedback(c);
            doc.setTextColor(35); doc.setFontSize(10);
            const wrapped = doc.splitTextToSize(fb, maxTextW);
            ensureSpace(wrapped.length * 12 + 22);
            doc.text(wrapped, margin, y);
            y += wrapped.length * 12 + 14;

            doc.setDrawColor(235);
            doc.line(margin, y, pageW - margin, y);
            y += 14;
          }

          const bottomLineY = pageH - margin - 72;
          const noteY = pageH - margin - 52;
          const labelY = pageH - margin - 34;

          if (y > bottomLineY - 10) { doc.addPage(); y = margin; }

          const overall = this.overallGrade;

          doc.setDrawColor(220);
          doc.line(margin, bottomLineY, pageW - margin, bottomLineY);

          doc.setTextColor(20);
          doc.setFont('helvetica', 'bold');
          doc.setFontSize(14);
          doc.text(`Gesamtnote: ${overall.symbol}`, margin, noteY);

          doc.setFont('helvetica', 'normal');
          doc.setFontSize(11);
          doc.setTextColor(70);
          doc.text(overall.label, margin, labelY);

          doc.setTextColor(120);
          doc.setFontSize(9);
          doc.text(`Summe Gewichtung: ${this.weightSum}%`, margin, pageH - 22);

          const safe = (s) => (String(s || '')
            .split('')
            .filter(ch => /[a-z0-9äöüß _-]/i.test(ch))
            .join('')
            .trim()
            .replaceAll(' ', '_')) || 'X';

          doc.save(`Bewertungsbogen_${safe(studentName)}_${safe(topic)}.pdf`);
        }
      };
    }
  </script>
</body>
</html>